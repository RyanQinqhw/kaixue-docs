在协程系列的前两篇文章中，我们介绍了：

* 协程的概念与作用
* 挂起的本质与挂起函数的使用

本篇文章将和大家一起探索，协程挂起的「非阻塞式」到底是什么意思。

### 什么是「非阻塞式」

上期文章我们讲过，协程的挂起是「非阻塞式」的，那它到底是什么意思呢？

#### 协程的「非阻塞」是什么？

让我们来看看下面的例子：

```kotlin
🏝️
main {
    val user = api.requestUser() // 👈 耗时操作
    updateView(user) // 👈 ui 操作
}
```

在主线程中，我们执行了一个耗时操作，成功地把主线程「阻塞」住了，界面会因为耗时操作而卡顿。

如果这个时候用上协程：

```kotlin
🏝️
main {
    GlobalScope.launch(Dispatchers.Main).lauch {
        val user = supsendingRequestUser()
        updtaeView(user)
    }
    
    private suspend fun supsendingRequestUser() : User = withContext(Dispatchers.IO) {
    	api.requestUser() // 👈 作为 withContext 的返回值
	}
}
```

从上面的例子看出，协程用 `withContext` 的挂起函数，疏通了原先「阻塞」的主线程，因此，我们才说协程的挂起是「非阻塞式」的。

简单点来说，这个所谓的「非阻塞式」，它本质上其实指的是**「不卡线程」**这件事。因为挂起函数把线程切换到 IO 线程上，所以主线程不会卡住。

#### 线程也有「非阻塞」？

我们看回那个被阻塞的例子，假如我们用线程来做：

```kotlin
🏝️
main {
     👇
    Thread {
        val user = api.requestUser()
        ...
    }.start()
}
```

我们创建了一个线程让耗时操作在新的线程中的执行，这样的主线程还会卡么？

当然是不会，耗时操作都在子线程中了。因此，线程其实也是「非阻塞式」的。

网上有一种说法是「协程的挂起是非阻塞式的，而线程是阻塞式的」，显得协程的异步比线程的异步高级，这有明显的误导性。

这里的「线程的阻塞式」指的是单线程是阻塞的，就像上面的主线程会被耗时操作「阻塞」住，但是多线程就可以避免「阻塞」的情况。而单协程则可以是「非阻塞」的，因为它可以利用挂起函数来切线程。

因此，协程的挂起函数和 Java 原始的线程切换，其实都是非阻塞式的，只是协程用了「看起来阻塞，其实非阻塞」的写法而已。

#### 协程的「非阻塞式」比线程的高效？

> 如果用线程来处理网络请求，在网络请求返回之前，线程一直在等着它，是处于阻塞状态不做事的，他说这就导致了线程利用率不高；而如果用协程，由于协程在等待网络请求的过程中会被挂起，线程没有被阻塞，这就提高了线程的利用率。

这个说法乍一看「有理有据，令人信服」，但仔细一想就发现有不少问题。

首先，所有的代码本质上都是阻塞式的，而只有比较耗时的代码才会导致人类可感知的等待。

其次我们来看看让我们感到「阻塞」的耗时操作，一般分为两种：

* CPU 计算的耗时；
* I/O 计算的耗时。

我们平时常见的网络请求属于 I/O 操作，而 CPU 计算的耗时一般是高清视频解码之类的需要运用 CPU 进行大量计算的。

所以网络请求的性能瓶颈是 I/O，这个时候 CPU 一般在等 I/O（硬盘/内存）的读写操作，所以线程才会被网络交互所阻塞。这种阻塞式**不可避免**的。

这种情况下，我们只能让线程慢慢处理它。因为网络传输的性能是低于 CPU 的性能，所以线程只能等待，但是它本质上还是在工作的。

我们之前也提到了，协程的挂起的本质是切换线程。我们把网络请求的挂起，本质上还是把这段 I/O 切换到后台线程，然后把主线程空出来。所以不存在网络请求到了所谓的「等待阶段」再挂起一次，来把这个网络线程空置出来，让它去做别的网络交互。

总而言之，挂起的本质是切换线程，只是它能够在完成之后自动切回原先的线程。

最后，我们可以用个例子来简化对「非阻塞式」的理解，今天你去热门餐馆吃饭：

- 自己取号排队等着，就是线程被阻塞；
- 让友人排队，你自己去逛街，就是开启子线程避免阻塞；
- 用个小程序取号，自己去逛街，小程序到号叫你回去吃饭，就是用协程避免阻塞。

用小程序取号，看着就像是你自己完成取号逛街吃饭的串行工作，这就跟协程一样，用看似阻塞的写法写了非阻塞代码。但其实是你利用了手机里的程序，让耗时工作切到后台线程，并在耗时任务完成后自动切回主线程。

### 协程与线程

上面讲了很多协程和线程，那么协程和线程是什么关系呢？

在 Kotlin 里，协程就是基于线程来实现的一种更上层的工具 API。就像 Handler API 一样，协程它就是一个**基于线程的上层框架**。

### 协程的轻量级

首先，我们来看看官网对协程轻量级的描述：

![](https://camo.githubusercontent.com/cda374fe45b15d886aa4bb081c8b3726c4f58bf0/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303679386d4e36677931673738626f736e7664346a3331696c3075307464692e6a7067)

但这种说法不仅是有误导性的，而且完全是错误的。因为它这这个例子里的协程代码，本质上是把所有内容都放进了一个线程池来做事，它拿来和 100_000 个 Thread 比较性能，那么别人尝试过后一定会出现内存不足。

* 首先，它比较的对象是 Thread。
  * 其实协程更接近的比较对象应该是 Java 的线程池 API，也就是 ExecutorService 那几个类。如果和它们做比较，使用和不使用协程的性能就不相上下了；

* 其次，协程的对比对象里使用的是 Thread.sleep() 方法。
  * 如果用普通的线程池和协程比较，依然会出现协程性能更高的结果；但其实协程这里的「延时」操作对应的应该是 Java 里的 `Executors.newSingleThreadScheduledExecutor()` 。如果换成这个 Executor 来对比，那用不用协程的性能就真的彻底没有区别了。

Thread 是最底层的控件，Executor 和 Coroutine 都是基于它所造出来的工具包，Kotlin 官方偷换了概念，把直接使用 Thread 说成是比协程重，显得好像协程有性能上的优势一样，显然不太妥当。

### 协程与 RxJava

协程能够帮助我们解决避免嵌套的复杂并发代码，这点 `RxJava` 也是一样的。那么协程与它相比有什么区别呢？

`RxJava` 是使用流式结构处理切换线程，使用 `subscribeOn` 指定上游线程，使用 `observeOn` 切换每个下游线程，而协程则是利用挂起函数切换线程，并且自动切回原先线程，把操作符都省略了。

`RxJava` 就像一把多功能的瑞士军刀，它定义了 `Obserable` 这个异步操作集合类，提供上百种常用操作符，让你在各种复杂的场景中游刃有余。协程像是一把匕首，简单但锋利，它能简单而清晰地完成并发操作，不像军刀一样，要你熟悉每种刀的准确用法，以避免不可预知的错误。

### 总结

在最后，我们再来回顾一下 Kotlin 协程系列的素质三连：

* 协程是轻量级线程，它可以让复杂的并发代码变得简单且清晰；
* 协程的挂起就是一个稍后会被自动切回来的线程调度操作；
* 挂起的非阻塞式就是它能用同步的代码写出非阻塞的操作。

希望大家能通过我们这个协程系列的讲解能帮助大家提高对 Kotlin 协程的理解，也欢迎继续关注「码上开学」的其它教程。

#### 练习题

使用协程实现一个网络请求：

* 等待时显示 Loading；
* 请求成功或者出错让 Loading 消失；
* 请求失败需要提示用户请求失败了。