### **上期回顾**

在上一期中我们讲清楚了：

- 协程是什么
- 协程好在哪里
- 协程怎么用



我们大部分情况下是用 `launch` 函数创建协程，其实官方提供了三个方法来创建协程：

- `runBlocking`
- `launch`
- `async`

`runBlocking` 通常适用于单元测试的场景，而业务开发中不会用到这种方法，因为它是线程阻塞的。

我们主要来对比 `launch` 与 `async` 这两个函数。

- 相同点：都是可以用来启动一个协程。

- 不同点：返回值的不同：
    - `launch` 会返回一个 `Job` 对象

    - `async `会返回一个 `Deferred` 对象

`Job`中封装了协程需要执行的代码逻辑，同时 `Job` 有简单的生命周期，也可以被取消。

`Job` 在完成时是没有返回值的，如果需要返回值，这个时候就需要 `Deferred` 出马。

关于 `Job`，`Deferred` 更深入的知识就不在这里过多阐述，我们目前只需要了解到：

- `Job` 是有简单的生命周期，没有返回值
- `Deferred` 是继承 `Job` 的且带有返回值

那 `async` 中的 `Deferred` 的返回值是如何得到的呢？

我们调用它的 `Deferred.await()` 方法就可以得到返回值了。



接下来我们继续看看 `async` 是如何使用的，先回忆一下上期中的一个场景：

```kotlin
🏝️
coroutineScope.launch(Dispatchers.Main) {
    //                      👇  async 函数启动新的协程
    val avatar: Deferred = async { api.getAvatar(user) }    // 获取用户头像
    val logo: Deferred = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo
    //            👇          👇   获取返回值
    show(avatar.await(), logo.await()) 						// 更新 UI
}
```

可以看到 avatar 和 logo 的类型就是 `Deferred` ，通过 `await` 获取结果并且更新到 UI 上显示。

`await` 的方法签名如下：

```kotlin
🏝️
public suspend fun await(): T
```

前面有个关键字是之前没有见过的 —— `suspend`，也是上期最后我们留下的一个问号：协程最核心的那个「非阻塞式」的「挂起」到底是怎么回事？

所以接下来，我们的核心内容就是来好好说一说这个「挂起」。



### 「挂起」的本质

`suspend` 就是挂起的意思，它是一个拟人化的动作。

大家肯定都洗过衣服吧，我们洗完衣服后都要挂到衣架上把衣服晾干，而把衣服「挂」在晾衣架后，你不会再去管衣服如何被晒干就去看「码上开学」了，所以我们只用挂起衣服，仅此而已。

这个场景其实跟协程里的「挂起」suspend 是一个意思。

那协程中「挂起」的对象到底是什么？挂起线程，还是挂起函数？

都不对，**我们挂起的对象是协程。**



还记得协程是什么吗？

启动一个协程可以使用 `launch`或者`async` 函数，协程其实就是这两个函数中闭包的代码块。

`launch` ，`async` 或者其他函数创建的协程，在执行到某一个 `suspend` 函数的时候，这个协程会被 suspend，也就是被挂起。

那此时又是从哪里挂起？

**从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离。**

注意，不是这个协程停下来了！
是脱离，当前线程不再管这个协程要去做什么了。

让我们先回到之前的晾晒衣服的日常情景中，我尝试把情景转换成伪代码，让你更好理解：

```kotlin
// 我开始执行任务
// 我会用 1️⃣2️⃣3️⃣ 来标注任务的结果顺序
I.post {
    // 1️⃣ 把所有衣服挂起来
    clothes.forEach {
        handUp(it)
    }
    // 3️⃣ 挂起完毕后，启动一个协程，作用是让衣服干掉（耗时操作）
    launch {
        drying(clothes)
    }
    // 2️⃣ 看码上开学
    learn()
}
```

这里有三件事情

- 挂起所有衣服
- 看码上开学
- 让衣服干掉

但是对于「我」来说，我只串行做了「挂起衣服」和「学习」两件事情，「让衣服干掉」是「我」没有关心的事情了。

其实这里的「我」就可以看做是一个「线程」，「让衣服干掉」就是一个协程。

应该就好理解了吧。



我们先对「挂起」有了一个基础概念后，接下来分别来看看，互相脱离的线程和协程具体发生了什么：

**线程：**

在协程的代码块中，线程运行到了 `suspend` 函数这里时跳出协程代码块。

之后线程继续做它该做的事情，如果它是一个后台线程，那这个线程接下来可能就没事干了，或者去执行别的后台任务。

总之，跟 Java 线程池里的线程在工作结束之后是完全一样的：要么回收掉，要么再利用。

而如果这个线程是 Android 的主线程，那它在这里执行完毕之后就继续回去工作，也就是继续 60 次的界面刷新任务。



我们再丰富下之前的伪代码，因为当衣服晾干后，我们都会需要把衣服整理好收起来，放进衣柜里：

```kotlin
// 「我」开始执行任务
// 我会用 1️⃣2️⃣3️⃣ 来标注任务结果顺序
I.post {
  // 1️⃣ 「我」把所有衣服挂起来
    clothes.forEach {
        handUp(it)
    }
    // 3️⃣ 挂起完毕后，启动一个协程，作用是让衣服干掉（耗时操作），之后「我」再把它们收起来
    launch {
        drying(clothes）      // 👈 在 IO 线程晒干衣服
        fold(clothes)         // 👈 晒干后，回到「我」，进行整理衣服
    }
    // 2️⃣ 「我」在码上开学学习
    learn()
}

suspend fun drying(clothes: List<Clothes>) = withContext(Dispatchers.IO) {
  ...
}
```

「我」就是这个线程，其实看我做了哪些事情，就是当前线程在做什么。

运行到编号 3️⃣ 的时候，就启动了一个协程，当运行到 `drying` 这个挂起函数的时候，当前线程就会跳出整个 `launch`包裹的代码块，也就是协程。

这时候当前线程并没有停止工作，而是继续运行到编号 2️⃣ `learn` 函数。

这个时候你可能就会疑问了，那 `launch` 包裹的剩下代码怎么办？

接下来我们看看协程这部分代码。



**协程：**

线程的代码在到达 `suspend` 函数的时候被掐断，接下来协程会从这个 `suspend` 函数开始继续往下执行，不过 —— 是在指定的线程。

谁指定的？

 `suspend` 函数指定的，比如，我们这个例子中，函数内部的 `withContext`传入的 `Dispatchers.IO` 所指定的 IO 线程。

`Dispatchers` 调度器，它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行，关于`Dispatchers` 的深入我们后续再讲 。

那我们平日里常用到的调度器有哪些？

常用的 `Dispatchers` ，有以下三种：

- Dispatchers.Main：Android 中的主线程
- Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求
- Dispatchers.Default：适合 CPU 密集型的任务，比如计算 

紧接着在 `suspend` 函数执行完成之后，协程为我们做的最爽的事就来了：会**自动帮我们把线程再切回来**。

这个「切回来」的动作，在 Kotlin 里叫做 [resume](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/resume.html)，恢复。

我将之前的场景做了一个动图，方便大家理解「切走线程之后，又自动切回来的过程」：

 ![](https://tva1.sinaimg.cn/large/006y8mN6gy1g7ghfel7y9g30py0s01kx.gif)

- 绿色是当前线程做的事情，红色是挂起函数从当前线程切走后执行的耗时操作
- 当调用到`suspend`修饰的函数的时候，协程会从当前线程切到 IO 线程，然后执行 `drying` 中的具体操作
- 等待几秒后，耗时操作执行完毕，协程会执行 resume 操作，回到当前线程上，之后正常往下执行。

通过上面的分析， 我们可以知道「挂起」实际上就是切了一个线程，不过与普通的切线程的区别在于，挂起函数执行完成后，协程会重新切回它原先所在的线程。

再简单来讲，在 Kotlin 中所谓的挂起，就是一个稍后会被自动切回来的线程调度操作。



### 怎么就「挂起」了？

我们了解到了什么是「挂起」后，再接着看看这个「挂起」是怎么做到的。

先随便写一个自定义的 `suspend`函数：

```kotlin
🏝️
suspend fun suspendingPrint() {
  println("Thread: ${Thread.currentThread().name}")
}

I/System.out: Thread: main
```

输出的结果还是在主线程。

为什么没切换线程？因为它不知道往哪切，需要我们告诉它。

对比之前例子中 `drying` 函数代码：

```kotlin
🏝️
//                                               👇
suspend fun drying(clothes: List<Clothes>) = withContext(Dispatchers.IO) {
  ...
}
```

我们可以发现不同之处其实在于 `withContext`函数。

其实通过 `withContext` 源码可以知道，它本身就是一个挂起函数，它接收一个 `Dispatcher` 参数，依赖这个 `Dispatcher` 参数的指示，你的协程被挂起，然后切到别的线程。

所以这个 `suspend`，其实并不是起到把任何把协程挂起，或者说切换线程的作用。

真正挂起协程这件事，是 Kotlin 的协程框架帮我们做的。

所以我们想要自己写一个挂起函数，仅仅只加上 `suspend` 关键字是不行的，还需要函数内部直接或间接地调用到 Kotlin 协程框架自带的 `suspend`函数才行。



### suspend 的意义？

这个 `suspend` 关键字，既然它并不是真正实现挂起，那它的作用是什么？

**它其实是一个提醒。**

函数的创建者对函数的使用者的提醒：我是一个耗时函数，我被我的创建者用挂起的方式放在后台运行，所以请在协程里调用我。



为什么 `suspend` 关键字并没有实际去操作挂起，但 Kotlin 却把它提供出来？

因为它本来就不是用来操作挂起的。

挂起的操作 —— 也就是切线程，依赖的是挂起方法里面的实际代码，而不是这个关键字。

所以这个关键字，**只是一个提醒**。

还记得刚才我们尝试自定义挂起函数的方法吗？

```kotlin
🏝️
// 👇 redundant suspend modifier
suspend fun suspendingPrint() {
  println("Thread: ${Thread.currentThread().name}")
}
```

如果你创建一个 `suspend` 函数但它内部不包含真正的挂起逻辑，编译器会给你一个提醒：`redundant suspend modifier`，告诉你这个 `suspend` 是多余的。

因为你这个函数实质上并没有发生挂起，那你这个 `suspend` 关键字只有一个效果：就是限制这个函数只能在协程里被调用，如果在非协程的代码中调用，就会编译不通过。

所以，创建一个 `suspend` 函数，为了让它包含真正挂起的逻辑，要在它内部直接或间接调用 Kotlin 自带的 `suspend` 函数，你的这个 `suspend` 才是有意义的。



### 怎么自定义 suspend 函数？

在了解了挂起到底是什么、`suspend` 关键字到底有什么意义之后，我们就可以进入下一个话题了：怎么自定义 `suspend` 函数。

这个「怎么自定义」其实分为两个问题：

- 什么时候需要自定义 suspend 函数？
- 写的时候怎么写？

#### 什么时候需要自定义 suspend 函数？

如果你的某个函数比较耗时，那就把它写成 `suspend` 函数。这就是原则。

耗时操作一般分为两类：I/O 操作和 CPU 计算工作。比如文件的读写、网络交互、图片的模糊或者美化处理，都是耗时的，通通可以把它们写进 `suspend` 函数里。

另外这个「耗时」还有一种特殊情况，就是这件事本身做起来并不慢，但它需要等待，比如 5 秒钟之后再做这个操作。这种也是 `suspend` 函数的应用场景。

#### 写的时候怎么写？

给函数加上 `suspend` 关键字，然后在 `withContext` 把函数的内容包住就可以了。

提到用 `withContext`是因为它在挂起函数里功能最简单直接：把线程自动切走和切回。

当然并不是只有 `witchContext` 这一个函数来辅助我们实现自定义的 `suspend` 函数，比如还有一个挂起函数叫  `delay`，它的作用是等待一段时间后再继续往下执行代码。

使用它就可以实现刚才提到的等待类型的耗时操作：

```kotlin
🏝️
suspend fun suspendUntilDone() {
  while (!done) {
    delay(5)
  }
}
```

这些东西，在我们初步使用协程的时候不用立马接触，可以先把协程最基本的方法和概念理清楚。

### 总结

所以我们今天整个文章其实就在理清一个概念：什么是挂起？
**挂起，就是一个稍后会被自动切回来的线程调度操作。**

好，关于协程中的「挂起」我们就解释到这里。

可能你心中还会存在一些疑惑：
- 协程中挂起的「非阻塞式」到底是怎么回事？
- 协程和 RxJava 在切换线程方面功能是一样的，都能让你写出避免嵌套回调的复杂并发代码，那协程还有哪些优势，或者让开发者使用协程的理由？

这些疑惑的答案，我们都会在下一章节中全部揭晓。


### 练习题

使用协程下载一张图，并行进行**两次**切割

- 一次切成大小相同的 4 份，取其中的第一份
- 一次切成大小相同的 9 份，取其中的最后一份

得到结果后，将它们展示在两个 ImageView 上。