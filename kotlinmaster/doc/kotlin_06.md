### **上期回顾**

在上一期中我们讲清楚了：

- 协程是什么
- 协程的优点
- 协程的基础用法

如果对于这三点还存有疑惑可以回去看一遍文章后，再继续学习本节内容。



在上一期我们大部分创建一个协程是使用的 `launch()` 函数，其实在 `GlobalScope` 单例中可以看到三个方法用来创建协程：

- `runBlocking()`
- `launch()`
- `async()`

方法一通常适用于单元测试的场景，而业务开发中不会用到这种方法，因为它是线程阻塞的。

我们主要来对比 `launch()` 与 `async()` 这两个函数的异同。



它们相同之处都是可以用来启动一个协程。

它们的不同之处在于返回值的不同：

`launch()` 会返回一个不携带任何结果值的 `Job` 对象。

`async() `会返回一个 `Deferred` 对象。

对于 `Job`（任务），其中封装了协程中需要执行的代码逻辑，同时 `Job` 有简单的生命周期，也可以被取消。Job 在完成时是没有返回值的，如果需要返回值，这个时候就应该是 `Deferred` 出马。

关于 `Job`，`Deferred` 更深入的知识就不在这里过多阐述，我们目前只需要了解到：

- `Job` 是有简单的生命周期，没有返回值
- `Deferred` 是继承 `Job` 的且带有返回值

那 `Deferred` 的返回值是如何得到呢？

我们调用它的 `await()` 方法就可以得到返回值了。



接下来我们继续看看 `async()` 是如何使用的，先让我们回忆一下上期中有使用到的一个场景：

使用协程，把两个并行请求写成上下两行，最后再把结果进行合并

```kotlin
🏝️
coroutineScope.launch(Dispatchers.Main) {
    //            👇  async 函数启动新的协程
    val avatar = async { api.getAvatar(user) }    // 获取用户头像
    val logo = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo
    //            👇          👇   获取返回值
    show(avatar.await(), logo.await()) 						// 更新 UI
}
```

这是 `async()` 的一个常见使用场景，这里完成了让「获取用户头像」和「获取用户所在公司的 logo」并行请求。

最后再通过 `await()` 获取结果并且更新到 UI 上显示。

如果你看 `Deferred` 的源码，你可以发现其实 `await()` 方法前有个关键字是之前没有见过的—— `suspend`，也是上期最后我们留下的一个问号：协程最核心的那个「非阻塞式」的「挂起」到底是怎么回事？

所以接下来，我们的核心内容就是来好好说一说这个「挂起」。



### 「挂起」的本质

`suspend` 这个单词的翻译：挂；暂停；暂缓。

这里我们取的意思是「挂」，是一个动作，是一个拟人化的动作。

大家肯定都洗过衣服吧，无论是手搓还是洗衣机，最后我们都需要把衣服晾晒起来，目的是为了让洗过衣服中的水分蒸发掉，我们把洗好的衣服「挂」在晾衣架，如果你有立式烘干机，那么你是讲它「挂」在烘干机里，挂好了，你就没有管这件事情了对吧？你可能就去看码上开学学习新的知识了，你根本不会再去管衣服如何晒干烘干这件事情了，我们只用挂起它，仅此而已。

这个场景特别日常，我相信每个人都体会过，情景中我不断强调的「挂」，其实跟协程里的「挂起」suspend 是一个意思。



在情景中，我们挂起的对象是衣服，那协程中「挂起」的对象到底是什么？挂起线程，还是挂起函数？

**都不对，我们挂起的对象是协程。**



还记得协程是什么吗？

在上期回顾中我们讲到了启动一个协程可以使用 `launch()`或者`async()` 函数，协程其实就是这两个函数中闭包的代码块。

`launch()` ，`async()` 或者其他函数创建的协程，在执行到某一个` suspend` 函数的时候，这个协程会被 suspend，也就是被挂起。



那此时又是从哪里挂起？

**从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离。**

注意，不是这个协程停下来了！是脱离，当前线程不再管它要去做什么了。



是不是还是不太明白这线程协程到底在干嘛？没有关系。

让我们先回到之前的晾晒衣服的日常情景中，我尝试把情景转换成伪代码，让你更好理解：

```
// 我开始执行任务
// 我会用 1️⃣2️⃣3️⃣ 来标注任务顺序结果
I.post {
  // 1️⃣ 把所有衣服挂起来
	clothes.forEach {
		handUp(it)
	}
	// 3️⃣ 挂起完毕后，启动一个协程，作用是让衣服干掉（耗时操作）
	launch {
		drying（clothes）
	}
	// 2️⃣ 在码上开学学习
	learn()
}
```

应该挺清晰的看到有三件事情

- 挂起所有衣服
- 在码上开学学习
- 让衣服干掉

但是对于「我」来说，我只串行做了「挂起衣服」和「学习」两件事情，「让衣服干掉」是「我」没有关心的事情了。

其实这里的「我」就可以看做是一个「线程」，「让衣服干掉」就是一个协程。

应该就好理解了吧？



我们先对整体有了一个基础概念后，接下来分别来看看，这两个互相脱离的线程和协程具体发生了什么：

**线程：**

在协程的代码块中，线程运行到了 `suspend` 函数这里时执行完毕，跳出协程代码块。

之后线程继续做它该做的事情，如果它是一个后台线程，那这个线程接下来可能就没事干了，或者去执行别的后台任务。

总之，跟 Java 线程池里的线程在工作结束之后是完全一样的：要么回收掉，要么再利用。

而如果这个线程是 Android 的主线程，那它在这里执行完毕之后就继续回去工作，也就是继续 60 次的界面刷新任务。



我们再丰富下之前的伪代码，因为当衣服晾干后，我们都会需要把衣服整理好起来，放进衣柜里：

```kotlin
// 「我」开始执行任务
// 我会用 1️⃣2️⃣3️⃣ 来标注任务顺序结果
I.post {
  // 1️⃣ 「我」把所有衣服挂起来
	clothes.forEach {
		handUp(it)
	}
	// 3️⃣ 挂起完毕后，启动一个协程，作用是让衣服干掉（耗时操作），之后再「我」再它们整理起来
	launch {
		drying(clothes）      // 👈 在 IO 线程晒干衣服
		fold(clothes)         // 👈 晒干后，回到「我」，进行整理衣服
	}
	// 2️⃣ 「我」在码上开学学习
	learn()
}

suspend fun drying(clothes: List<Clothes>) = withContext(Dispatchers.IO) {
  ...
}
```

「我」就是这个线程，其实看我做了哪些事情，就是当前线程在做什么。

运行到编号 3️⃣ 的时候，就启动了一个协程，当运行到 `drying()` 这个挂起函数的时候，当前线程就会跳出整个 `launch()`包裹的代码块，也就是协程。

这时候当前线程并没有停止工作，而是继续运行到编号 2️⃣ `learn()` 函数。

这个时候你可能就会疑问了，那 `launch()` 包裹的剩下代码怎么办？

这个时候就是该协程出马了。



**协程：**

协程的代码在到达 `suspend` 函数的时候被掐断，接下来它会从这个 `suspend` 函数开始继续往下执行，不过——是在指定的线程。

谁指定的？

 `suspend` 函数指定的，比如，我们这个例子中，函数内部的 `withContext()`传入的 `Dispatchers.IO` 所指定的 IO 线程。

`Dispatchers` 调度器，它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行，关于`Dispatchers` 的深入我们后续再讲 。

那我们平日里常用到的调度器有哪些？

常用的 `Dispatchers` ，有以下三种：

- Dispatchers.Main：Android 中的主线程
- Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求
- Dispatchers.Default：适合 CPU 密集型的任务，比如解析 JSON 文件，排序一个较大的 list 

紧接着在 `suspend` 函数执行完成之后，协程为我们做的最爽的事就来了：会**自动帮我们把线程再切回来**。

这个「切回来」的动作，在 Kotlin 里叫做 [resume](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/resume.html)，恢复。

我将之前的场景做了一个动图，方便大家理解「切走线程之后，又自动切回来的过程」：

 ![](kotlin_06.gif)

- 绿色是当前线程做的事情，红色是挂起函数从当前线程切走后执行的耗时操作
- 当调用到`suspend`修饰的函数的时候，协程会从当前线程切到 IO 线程，然后执行 `drying()` 中的具体操作
- 等待几秒后，耗时操作执行完毕，协程会执行 resume 操作，回到当前线程上，之后正常往下执行。



通过上面的分析， 我们可以知道「挂起」suspend 其实就是：协程在执行有 `suspend` 标记的函数时，会被 suspend 也就是被挂起，而所谓的被挂起，实际上就是切了一个线程；

不过与普通的切线程的区别在于，挂起函数执行完成后，协程会重新切回它原先所在的线程。

再简单来讲，在 Kotlin 中所谓的挂起，就是一个稍后会被自动切回来的线程调度操作。



### 怎么就「挂起」了？

我们了解到了什么是「挂起」后，再接着看看这个「挂起」是怎么做到的。

先随便写一个自定义的 `suspend`函数：

```kotlin
🏝️
suspend fun suspendingPrint() {
  println("Thread: ${Thread.currentThread().name}")
}

I/System.out: Thread: main
```

输出的结果还是在主线程。

为什么切换线程？因为它不知道往哪切，需要我们告诉它。

对比之前例子中，自定义 `suspend` 函数代码：

```kotlin
🏝️
//                                       👇
suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {
    ...
}
```

我们可以发现不同之处其实在于 `withContext`函数。

其实通过源码可以知道，它本身就是一个挂起函数，它接收一个 `Dispatcher` 参数，依赖这个 `Dispatcher` 参数的指示，你的协程被挂起，然后切到别的线程。

所以这个 `suspend`，其实并不是起到把任何把协程挂起，或者说切换线程的作用。

真正要挂起协程，还需要你在 `suspend` 函数里调用另外一个 `suspend` 函数，而且这个里面的 `suspend` 函数需要是：

- 协程自带的 `suspend`函数
- 内部实现了协程挂起代码
- 直接或间接调用了某个自带的 `suspend` 函数

所以我们想要自己写一个挂起函数，仅仅只加上这个 `suspend` 关键字是不行的，还需要函数内部直接或间接地调用到自带的 `suspend`函数才行。



### suspend 的意义？

那这个 `suspend` 关键字，既然它并不是真正实现挂起，那它的作用是什么？

**它其实是一个提醒。**

函数的创建者对函数的使用者的提醒：我是一个耗时函数，我被我的创建者用挂起的方式放在后台运行，所以请在协程里调用我。



为什么 `suspend` 关键字并没有实际去操作挂起，但 Kotlin 却把它提供出来？

因为它本来就不是用来操作挂起的。

挂起的操作——也就是切线程——依赖的是挂起方法里面的实际代码，而不是这个关键字。

所以可以再次可以重申，这个关键字，**是一个提醒**。

还记得刚才我们尝试自定义挂起函数的方法吗？

```kotlin
🏝️
// 👇 redundant suspend modifier
suspend fun suspendingPrint() {
  println("Thread: ${Thread.currentThread().name}")
}
```

如果你创建一个 `suspend` 函数但却不在它内部调用别的 `suspend` 函数，编译器会给你一个提醒：`redundant suspend modifier`，告诉你这个 `suspend` 是多余的。

因为你这个函数实质上并没有发生挂起，那你这个 suspend 关键字只有一个效果：就是限制这个函数只能在协程里被调用。

所以，创建一个 `suspend` 函数，一定要在它内部调用别的 `suspend` 函数，你的这个 `suspend` 才能是有意义的。



那这个 `suspend` 关键字可以修饰哪些东西呢？

有三个，它们分别是：

- 普通函数
- 扩展函数（什么是扩展函数我们以后在讲）
- lambda 表达式

```kotlin
🏝️

// 普通函数
suspend fun suspendingPrint() = withContext(Dispatchers.IO) {}

// 扩展函数
suspend fun String.trim() = withContext(Dispatchers.IO) {}

// lambda 表达式
val lambdaAction = suspend {}
```



### 怎么自定义 suspend 函数？

在了解了挂起到底是什么、`suspend` 关键字到底有什么意义之后，我们就可以进入下一个话题了：怎么自定义 `suspend` 函数。

这个「怎么自定义」其实分为两个问题：

- 什么时候需要自定义 suspend 函数？
- 写的时候怎么写？

#### 什么时候需要自定义 suspend 函数？

如果你的某个函数比较耗时，那就把它写成 suspend 函数。这就是原则。

耗时操作一般分为两类：I/O 操作和 CPU 计算工作。比如文件的读写、网络交互、图片的模糊或者美化处理，都是耗时的，通通可以把它们写进 `suspend` 函数里。

另外这个「耗时」还有一种特殊情况，就是这件事本身做起来并不慢，但它需要等待，比如 5 秒钟之后再做这个操作。这种也是 `suspend` 函数的应用场景。

#### 写的时候怎么写？

给函数加上 `suspend` 关键字，然后在 `withContext()` 把函数的内容包住就可以了。

提到用 `withContext()`是因为它在挂起函数里功能最简单直接：把线程自动切走和切回。

当然并不是只有 `witchContext()` 这一个函数来辅助我们实现自定义的 `suspend` 函数，比如还有一个挂起函数叫  `delay()`，它的作用是等待一段时间后再继续往下执行代码。

使用它就可以实现刚才提到的等待类型的耗时操作：

```kotlin
🏝️
suspend fun suspendUntilDone() {
  while (!done) {
    delay(5)
  }
}
```

这些东西，在我们初步使用协程的时候不用立马接触，可以先把协程最基本的方法和概念理清楚，不着急。

所以我们今天整个文章其实就在理清一个概念：什么是挂起？挂起，就是一个稍后会被自动切回来的线程调度操作。

关于协程中的「挂起」就解释到这里。可能你心中会存在一些疑惑：

- 协程挂起的「非阻塞式」到底是怎么回事
- 协程和 RxJava 在切换线程方面功能是一样的，都能让你写出避免嵌套回调的复杂并发代码，那协程还有哪些优势，或者让开发者使用协程的理由？

这些疑惑的答案，我们都会在下一章节中全部揭晓。



### 练习题

1. 使用协程下载一张图，并行进行两次切割，一次切成大小相同的 4 份，取其中的第 2 个；一次切成大小相同的 9 份，取其中的第 3 个，得到结果后，将它们展示在两个 ImageView 上。