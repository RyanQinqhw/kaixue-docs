

### **上期回顾**

在上一期里，我们强调了 Kotlin 的协程其实是一个线程框架，同时也讲了协程的基本用法，但到最后也留下了一个大问号：协程最核心的那个「非阻塞式」的「挂起」到底是怎么回事？

今天，我们的核心内容就是来说一说这个「挂起」。

### 「挂起」的本质

这个「挂起」到底是挂起谁？挂起线程，还是挂起函数？

**都不是，挂起的是协程。**

还记得协程是什么嘛？

在上期我们有讲到启动一个协程我们可以使用 `launch()` 函数，协程就是 `launch()` 闭包的代码块。同时官方在 kotlinx.coroutines 库中同时也给了 `async()` 函数同样可以启动一个协程。它们的不同之处是在于返回值，`launch()` 会返回一个不会任何结果值的 Job 对象，而 `async()` 会返回一个 Deferred 

```Kotl
🏝️
public interface Deferred<out T> : kotlinx.coroutines.Job {
		···
    public abstract suspend fun await(): T
		···
}
```

我们可以把它当做一个轻量级的 Future ，最终通过 `await()` 来获取结果。`launch()` ，`async()` 或者其他函数创建的协程，在执行到某一个` suspend` 函数的时候，这个协程会被 suspend，被挂起。

那此时又是从哪里挂起？

**从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离。**

虽然 `suspend` 有暂停的意思，但并不代表协程会停下来，而是它所在的线程从这行开始不再继续执行它，这个时候它们开始兵分两路。为了方便理解，接下来我们会分别看看这两个互相脱离的线程和协程将会发生什么：

**线程：**

在协程的代码块中，线程运行到了 `suspend` 函数这里时执行完毕，跳出协程代码块。

之后线程继续做它该做的事情，如果它是一个后台线程，那这个线程接下来可能就没事干了，或者去执行别的后台任务，总之，跟 Java 线程池里的线程在工作结束之后是完全一样的：要么回收掉，要么再利用；而如果这个线程是 Android 的主线程，那它在这里突然执行完毕之后就继续回去工作。

什么叫继续回去工作？

我们先回到上一期最后的一个场景中

```kotlin
🏝️
launch(Dispachers.Main) {              // 👈 在 UI 线程开始
    val image = getImage(imageId)
    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程
}

suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {
    ...
}
```

这段执行在主线程的协程，它实际上会往你的主线程 `post() ` 一个新的任务，这个任务就是你的协程代码，所以上述代码也可以看作：

```kotlin
🏝️
handler.post {
    val image = getImage(imageId)
    avatarIv.setImageBitmap(image)
}
```

当执行到 `getImage` 也就是挂起函数的时候，实际上就是 `post()` 这个任务提前结束，这时候主线程继续回去工作，工作的内容是一秒钟 60 次的界面刷新任务。

那我们剩下的代码是如何处理的呢？接下来我们把视角切到协程看看。

**协程：**

协程的代码在到达 `suspend` 函数的时候被掐断，接下来它会从这个 `suspend` 函数开始继续往下执行，不过——是在指定的线程。谁指定的？ `suspend` 函数指定的，比如，我们这个例子中，函数内部的 `withContext()` 所指定的 IO 线程。

在 `suspend` 函数执行完成之后，协程为我们做的最爽的事就来了：会**自动帮我们把线程再切回来**。

按照之前的场景，我们的协程原本是运行在主线程，当代码遇到 `suspend` 函数的时候，会切换到 IO 线程执行代码，当这个函数执行完毕后，协程会再 `post()` 一个任务，让剩下的代码继续回到主线程执行。

如果还不好理解，我们可以把当前线程想象成一条流淌着的河流，遇到了一个分叉河道，协程就从这里流出（从正在执行它的线程脱离），然后过了一段时间，分叉的河道与主河道再次相会合并（切回来）。

这也是为什么指定线程的参数不叫 `Threads` 而是叫 `Dispatchers` （调度器），因为它不只能指定协程执行的线程，还能在 `suspend` 函数之后自动切回来——其实也不是一定会切回来，你也可以通过设置特殊的 `Dispatcher` 来让挂起方法执行完之后也不切回来，不过这是你的选择，而不是它的定位，挂起的定位就是「暂时切走，稍后再切回来」。



通过上面的分析， 我们可以知道「挂起」suspend 其实就是：协程在执行有 `suspend` 标记的函数时，会被 suspend 也就是被挂起，而所谓的被挂起，实际上就是切了一个线程；不过区别在于，挂起函数执行完成后，协程会重新切回它原先所在的线程。

再简单来讲，所谓的挂起，就是一个稍后会被自动切回来的线程调度操作。

顺便说一下，这个「切回来」的动作，在 Kotlin 里叫做 resume，恢复。



### 怎么就「挂起」了？

我们了解到了什么是「挂起」后，再接着看看这个「挂起」是怎么做到的。

先写一个自定义的 `suspend`函数：

```kotlin
🏝️
suspend fun suspendingPrint() {
  println("Thread: ${Thread.currentThread().name}")
}

I/System.out: Thread: main
```

输出的结果还是在主线程。

为什么切换线程？因为它不知道往哪切，需要我们告诉它。

对比之前例子中，自定义 `suspend` 函数代码：

```kotlin
🏝️
//                                       👇
suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {
    ...
}
```

不同之处在于 `withContext`函数，其实通过源码可以知道，它本身就是一个挂起函数，它接收一个 `Dispatcher` 参数，依赖这个 `Dispatcher` 参数的指示，你的协程被挂起，然后切到别的线程。

所以这个 `suspend`，其实并不起到任何把协程挂起，或者说切换线程的作用。真正要挂起协程，还需要你在 `suspend` 函数里调用另外一个 `suspend` 函数，而且这个里面的 `suspend` 函数需要是：

- 协程自带的 `suspend`函数
- 内部实现了协程挂起代码
- 直接或间接调用了某个自带的 `suspend` 函数

所以我们想要自己写一个挂起函数，仅仅只加上这个 `suspend` 关键字是不行的，还需要函数内部直接或间接地调用到自带的 `suspend`函数才行。



### suspend 的意义？

那这个 `suspend` 关键字，既然它并不是真正实现挂起，那它的作用是什么？

它其实是一个提醒。

函数的创建者对函数的使用者的提醒：我是一个耗时函数，我被我的创建者用挂起的方式放在后台运行，所以请在协程里调用我。



为什么 `suspend` 关键字并没有实际去操作挂起，但 Kotlin 却把它提供出来？

因为它本来就不是用来操作挂起的。挂起的操作——也就是切线程——依赖的是挂起方法里面的实际代码，而不是这个关键字。



记得刚才我们尝试自定义挂起函数的方法吗？

```kotlin
🏝️
// 👇 redundant suspend modifier
suspend fun suspendingPrint() {
  println("Thread: ${Thread.currentThread().name}")
}
```

如果你创建一个 `suspend` 函数但却不在它内部调用别的 `suspend` 函数，编译器会给你一个提醒：`redundant suspend modifier`，告诉你这个 `suspend` 是多余的。因为你这个函数实质上并没有发生挂起，那你这个 suspend 关键字只有一个效果：就是限制这个函数只能在协程里被调用。所以，创建一个 `suspend` 函数，一定要在它内部调用别的 `suspend` 函数，你的这个 `suspend` 才能是有意义的。



### 怎么自定义 suspend 函数？

在了解了挂起到底是什么、`suspend` 关键字到底有什么意义之后，我们就可以进入下一个话题了：怎么自定义 `suspend` 函数。

这个「怎么自定义」其实分为两个问题：

- 什么时候需要自定义 suspend 函数？
- 写的时候怎么写？

#### 什么时候需要自定义 suspend 函数？

如果你的某个函数比较耗时，那就把它写成 suspend 函数。这就是原则。

耗时操作一般分为两类：I/O 操作和 CPU 计算工作。比如文件的读写、网络交互、图片的模糊或者美化处理，都是耗时的，通通可以把它们写进 `suspend` 函数里。

另外这个「耗时」还有一种特殊情况，就是这件事本身做起来并不慢，但它需要等待，比如 5 秒钟之后再做这个操作。这种也是 `suspend` 函数的应用场景。

#### 写的时候怎么写？

给函数加上 `suspend` 关键字，然后在 `withContext()` 把函数的内容包住就可以了。

提到用 `withContext()`是因为它在挂起函数里功能最简单直接：把线程自动切走和切回。当然并不是只有 `witchContext()` 这一个函数来辅助我们实现自定义的 `suspend` 函数，比如还有一个挂起函数叫  `delay()`，它的作用是等待一段时间后再继续往下执行代码。

使用它就可以实现刚才提到的等待类型的耗时操作：

```kotlin
🏝️
suspend fun suspendUntilDone() {
  while (!done) {
    delay(5)
  }
}
```

这些东西，在我们初步使用协程的时候不用立马接触，可以先把协程最基本的方法和概念理清楚，不着急。

所以我们今天整个文章其实就在理清一个概念：什么是挂起？挂起，就是一个稍后会被自动切回来的线程调度操作。

关于协程中的「挂起」就解释到这里。可能你心中会存在一些疑惑：

- 协程挂起的「非阻塞式」到底是怎么回事
- 协程和 RxJava 在切换线程方面功能是一样的，都能让你写出避免嵌套回调的复杂并发代码，那协程还有哪些优势，或者让开发者使用协程的理由？

这些疑惑的答案，我们都会在下一章节中全部揭晓。



### 练习题